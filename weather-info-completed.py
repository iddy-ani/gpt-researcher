#!/usr/bin/env python3
'''
MCP Server: weather-info
Description: Provides weather information and forecasts for different locations

Generated by ExpertGPT MCP Builder
'''

import asyncio
import json
import aiohttp
import os
from datetime import datetime
from mcp.server import Server
from mcp.server.stdio import stdio_server
from mcp.types import (
    Resource,
    Tool,
    Prompt,
    TextContent,
    ImageContent,
    EmbeddedResource,
    CallToolRequest,
    ListToolsRequest,
    ListResourcesRequest,
    ReadResourceRequest,
    ListPromptsRequest,
    GetPromptRequest
)

# Initialize the MCP server
server = Server("weather-info")

# OpenWeatherMap API configuration
# Get your free API key from: https://openweathermap.org/api
# Set environment variable: OPENWEATHER_API_KEY=your_api_key_here
OPENWEATHER_API_KEY = os.getenv('OPENWEATHER_API_KEY', 'demo_key')
OPENWEATHER_BASE_URL = "https://api.openweathermap.org/data/2.5"

async def fetch_weather_data(url: str) -> dict:
    """Helper function to fetch data from OpenWeatherMap API"""
    try:
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                if response.status == 200:
                    return await response.json()
                elif response.status == 401:
                    return {"error": "Invalid API key. Please set OPENWEATHER_API_KEY environment variable."}
                elif response.status == 404:
                    return {"error": "Location not found. Please check the city name or coordinates."}
                else:
                    return {"error": f"API request failed with status {response.status}"}
    except Exception as e:
        return {"error": f"Network error: {str(e)}"}

def format_weather_data(data: dict, units: str = "celsius") -> str:
    """Format weather data into readable text"""
    if "error" in data:
        return f"Error: {data['error']}"
    
    try:
        location = f"{data['name']}, {data['sys']['country']}"
        temp = data['main']['temp']
        feels_like = data['main']['feels_like']
        humidity = data['main']['humidity']
        pressure = data['main']['pressure']
        description = data['weather'][0]['description'].title()
        
        # Convert temperature if needed
        temp_unit = "Â°C" if units == "celsius" else "Â°F"
        if units == "fahrenheit":
            temp = (temp * 9/5) + 32
            feels_like = (feels_like * 9/5) + 32
        
        wind_speed = data['wind']['speed']
        wind_deg = data['wind'].get('deg', 'N/A')
        
        return f"""Weather in {location}:
ðŸŒ¡ï¸ Temperature: {temp:.1f}{temp_unit} (feels like {feels_like:.1f}{temp_unit})
â˜ï¸ Conditions: {description}
ðŸ’§ Humidity: {humidity}%
ðŸŒªï¸ Wind: {wind_speed} m/s at {wind_deg}Â°
ðŸ“Š Pressure: {pressure} hPa
ðŸ“… Updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"""
    except KeyError as e:
        return f"Error parsing weather data: Missing field {e}"

def format_forecast_data(data: dict, days: int = 5) -> str:
    """Format forecast data into readable text"""
    if "error" in data:
        return f"Error: {data['error']}"
    
    try:
        location = f"{data['city']['name']}, {data['city']['country']}"
        forecast_text = f"ðŸŒ¤ï¸ {days}-Day Weather Forecast for {location}:\n\n"
        
        # Group forecasts by day
        daily_forecasts = {}
        for item in data['list'][:days * 8]:  # 8 forecasts per day (3-hour intervals)
            date = datetime.fromtimestamp(item['dt']).date()
            if date not in daily_forecasts:
                daily_forecasts[date] = []
            daily_forecasts[date].append(item)
        
        for date, forecasts in list(daily_forecasts.items())[:days]:
            day_name = date.strftime('%A, %B %d')
            
            # Get min/max temps for the day
            temps = [f['main']['temp'] for f in forecasts]
            min_temp, max_temp = min(temps), max(temps)
            
            # Get most common weather condition
            conditions = [f['weather'][0]['description'] for f in forecasts]
            main_condition = max(set(conditions), key=conditions.count).title()
            
            forecast_text += f"ðŸ“… {day_name}\n"
            forecast_text += f"   ðŸŒ¡ï¸ {min_temp:.1f}Â°C - {max_temp:.1f}Â°C\n"
            forecast_text += f"   â˜ï¸ {main_condition}\n\n"
        
        return forecast_text
    except KeyError as e:
        return f"Error parsing forecast data: Missing field {e}"


async def get_weather(arguments: dict) -> list[dict]:
    '''
    Get current weather for a specific location
    '''
    location = arguments.get('location', '')
    units = arguments.get('units', 'celsius')
    
    if not location:
        return [{
            "type": "text",
            "text": "Error: Location is required. Please provide a city name or coordinates."
        }]
    
    # Build API URL
    if OPENWEATHER_API_KEY == 'demo_key':
        return [{
            "type": "text",
            "text": "âš ï¸ Demo mode: Please set OPENWEATHER_API_KEY environment variable with your free API key from https://openweathermap.org/api\n\nDemo weather for " + location + ":\nðŸŒ¡ï¸ Temperature: 22.0Â°C (feels like 24.0Â°C)\nâ˜ï¸ Conditions: Partly Cloudy\nðŸ’§ Humidity: 65%\nðŸŒªï¸ Wind: 3.2 m/s at 180Â°\nðŸ“Š Pressure: 1013 hPa"
        }]
    
    # Determine if location is coordinates or city name
    try:
        # Try to parse as coordinates (lat,lon)
        if ',' in location:
            lat, lon = map(float, location.split(','))
            url = f"{OPENWEATHER_BASE_URL}/weather?lat={lat}&lon={lon}&appid={OPENWEATHER_API_KEY}&units=metric"
        else:
            # Treat as city name
            url = f"{OPENWEATHER_BASE_URL}/weather?q={location}&appid={OPENWEATHER_API_KEY}&units=metric"
    except ValueError:
        # If coordinate parsing fails, treat as city name
        url = f"{OPENWEATHER_BASE_URL}/weather?q={location}&appid={OPENWEATHER_API_KEY}&units=metric"
    
    # Fetch weather data
    weather_data = await fetch_weather_data(url)
    formatted_weather = format_weather_data(weather_data, units)
    
    return [{
        "type": "text",
        "text": formatted_weather
    }]

async def get_forecast(arguments: dict) -> list[dict]:
    '''
    Get weather forecast for a location
    '''
    location = arguments.get('location', '')
    days = arguments.get('days', 5)
    
    if not location:
        return [{
            "type": "text",
            "text": "Error: Location is required. Please provide a city name or coordinates."
        }]
    
    # Validate days parameter
    if days < 1 or days > 5:
        days = 5
    
    if OPENWEATHER_API_KEY == 'demo_key':
        return [{
            "type": "text",
            "text": f"âš ï¸ Demo mode: Please set OPENWEATHER_API_KEY environment variable with your free API key from https://openweathermap.org/api\n\nDemo {days}-day forecast for {location}:\n\nðŸ“… Today\n   ðŸŒ¡ï¸ 18.0Â°C - 25.0Â°C\n   â˜ï¸ Partly Cloudy\n\nðŸ“… Tomorrow\n   ðŸŒ¡ï¸ 16.0Â°C - 23.0Â°C\n   â˜ï¸ Light Rain\n\nðŸ“… Day 3\n   ðŸŒ¡ï¸ 20.0Â°C - 27.0Â°C\n   â˜ï¸ Sunny"
        }]
    
    # Build API URL for forecast
    try:
        # Try to parse as coordinates (lat,lon)
        if ',' in location:
            lat, lon = map(float, location.split(','))
            url = f"{OPENWEATHER_BASE_URL}/forecast?lat={lat}&lon={lon}&appid={OPENWEATHER_API_KEY}&units=metric"
        else:
            # Treat as city name
            url = f"{OPENWEATHER_BASE_URL}/forecast?q={location}&appid={OPENWEATHER_API_KEY}&units=metric"
    except ValueError:
        # If coordinate parsing fails, treat as city name
        url = f"{OPENWEATHER_BASE_URL}/forecast?q={location}&appid={OPENWEATHER_API_KEY}&units=metric"
    
    # Fetch forecast data
    forecast_data = await fetch_weather_data(url)
    formatted_forecast = format_forecast_data(forecast_data, days)
    
    return [{
        "type": "text",
        "text": formatted_forecast
    }]

async def convert_temperature(arguments: dict) -> list[dict]:
    '''
    Convert temperature between celsius and fahrenheit
    '''
    temperature = arguments.get('temperature')
    from_unit = arguments.get('from_unit', '').lower()
    to_unit = arguments.get('to_unit', '').lower()
    
    if temperature is None:
        return [{
            "type": "text",
            "text": "Error: Temperature value is required."
        }]
    
    if from_unit not in ['celsius', 'fahrenheit']:
        return [{
            "type": "text",
            "text": "Error: from_unit must be 'celsius' or 'fahrenheit'."
        }]
    
    if to_unit not in ['celsius', 'fahrenheit']:
        return [{
            "type": "text",
            "text": "Error: to_unit must be 'celsius' or 'fahrenheit'."
        }]
    
    try:
        temp_value = float(temperature)
        
        if from_unit == to_unit:
            result = temp_value
            return [{
                "type": "text",
                "text": f"ðŸŒ¡ï¸ {temp_value}Â° {from_unit.title()} = {result}Â° {to_unit.title()} (no conversion needed)"
            }]
        
        if from_unit == 'celsius' and to_unit == 'fahrenheit':
            result = (temp_value * 9/5) + 32
            symbol_from, symbol_to = "Â°C", "Â°F"
        elif from_unit == 'fahrenheit' and to_unit == 'celsius':
            result = (temp_value - 32) * 5/9
            symbol_from, symbol_to = "Â°F", "Â°C"
        
        return [{
            "type": "text",
            "text": f"ðŸŒ¡ï¸ Temperature Conversion:\n{temp_value}{symbol_from} = {result:.1f}{symbol_to}"
        }]
        
    except (ValueError, TypeError):
        return [{
            "type": "text",
            "text": "Error: Temperature must be a valid number."
        }]



async def read_current_weather() -> str:
    '''
    Current weather conditions for any location
    '''
    return """Current Weather Resource:
This resource provides real-time weather information for any location worldwide.

Available data includes:
â€¢ Temperature (current and feels-like)
â€¢ Weather conditions and description
â€¢ Humidity and atmospheric pressure
â€¢ Wind speed and direction
â€¢ Location information

Usage: Call the 'get-weather' tool with a location parameter.
Supports city names (e.g., "London", "New York") and coordinates (e.g., "40.7128,-74.0060").

API Status: """ + ("âœ… Active" if OPENWEATHER_API_KEY != 'demo_key' else "âš ï¸ Demo mode - Set OPENWEATHER_API_KEY environment variable")

async def read_weather_forecast() -> str:
    '''
    5-day weather forecast data
    '''
    return """Weather Forecast Resource:
This resource provides detailed weather forecasts for up to 5 days ahead.

Available forecast data includes:
â€¢ Daily temperature ranges (min/max)
â€¢ Weather conditions for each day
â€¢ Detailed hourly breakdowns
â€¢ Location-specific predictions

Usage: Call the 'get-forecast' tool with location and optional days parameter (1-5).
Supports the same location formats as current weather.

Forecast Details:
â€¢ Updates every 3 hours
â€¢ Covers temperature, precipitation, wind
â€¢ Includes weather condition descriptions

API Status: """ + ("âœ… Active" if OPENWEATHER_API_KEY != 'demo_key' else "âš ï¸ Demo mode - Set OPENWEATHER_API_KEY environment variable")



async def get_weather_summary(arguments: dict) -> dict:
    '''
    Generate a natural weather summary
    '''
    location = arguments.get('location', 'your location')
    weather_data = arguments.get('weather_data', '')
    days = arguments.get('days', 1)
    forecast_data = arguments.get('forecast_data', '')
    
    prompt_text = f"""Create a natural, conversational weather summary for {location}.

Current Weather Data:
{weather_data if weather_data else 'No current weather data provided'}

Forecast Data:
{forecast_data if forecast_data else 'No forecast data provided'}

Please provide a friendly, easy-to-understand summary that includes:
- Current conditions in everyday language
- What to expect for the next {days} day(s)
- Any weather-related recommendations or observations
- A brief outlook on whether it's good weather for outdoor activities

Keep the tone conversational and helpful, as if talking to a friend."""

    return {
        "description": "Generate a natural weather summary",
        "arguments": [
            {"name": "location", "description": "Location for weather information", "required": True},
            {"name": "weather_data", "description": "Current weather data", "required": False},
            {"name": "days", "description": "Number of days", "required": False},
            {"name": "forecast_data", "description": "Forecast data", "required": False}
        ],
        "prompt": prompt_text
    }

async def get_travel_advice(arguments: dict) -> dict:
    '''
    Weather-based travel recommendations
    '''
    location = arguments.get('location', 'your destination')
    weather_data = arguments.get('weather_data', '')
    days = arguments.get('days', 1)
    forecast_data = arguments.get('forecast_data', '')
    
    prompt_text = f"""Provide weather-based travel advice for {location}.

Current Weather Data:
{weather_data if weather_data else 'No current weather data provided'}

Forecast Data for next {days} day(s):
{forecast_data if forecast_data else 'No forecast data provided'}

Please provide practical travel recommendations including:
- What to pack (clothing, accessories, gear)
- Best times to be outdoors
- Activities that would be enjoyable in this weather
- Any weather-related precautions or alerts
- Transportation considerations
- Indoor alternatives if weather is unfavorable

Focus on actionable advice that helps travelers make the most of their trip regardless of weather conditions."""

    return {
        "description": "Weather-based travel recommendations",
        "arguments": [
            {"name": "location", "description": "Location for weather information", "required": True},
            {"name": "weather_data", "description": "Current weather data", "required": False},
            {"name": "days", "description": "Number of days", "required": False},
            {"name": "forecast_data", "description": "Forecast data", "required": False}
        ],
        "prompt": prompt_text
    }


@server.list_tools()
async def handle_list_tools() -> list[Tool]:
    """List available tools."""
    return [
        Tool(name="get-weather", description="Get current weather for a specific location", inputSchema={"properties": {"location": {"description": "City name or coordinates", "type": "string"}, "units": {"default": "celsius", "enum": ["celsius", "fahrenheit"], "type": "string"}}, "required": ["location"], "type": "object"}),
        Tool(name="get-forecast", description="Get weather forecast for a location", inputSchema={"properties": {"days": {"default": 5, "maximum": 7, "minimum": 1, "type": "integer"}, "location": {"description": "City name or coordinates", "type": "string"}}, "required": ["location"], "type": "object"}),
        Tool(name="convert-temperature", description="Convert temperature between celsius and fahrenheit", inputSchema={"properties": {"from_unit": {"enum": ["celsius", "fahrenheit"], "type": "string"}, "temperature": {"description": "Temperature value", "type": "number"}, "to_unit": {"enum": ["celsius", "fahrenheit"], "type": "string"}}, "required": ["temperature", "from_unit", "to_unit"], "type": "object"})
    ]

@server.call_tool()
async def handle_call_tool(name: str, arguments: dict) -> list[dict]:
    """Handle tool calls."""
    if name == "get-weather":
        return await get_weather(arguments)
    if name == "get-forecast":
        return await get_forecast(arguments)
    if name == "convert-temperature":
        return await convert_temperature(arguments)
    else:
        raise ValueError(f"Unknown tool: {name}")

@server.list_resources()
async def handle_list_resources() -> list[Resource]:
    """List available resources."""
    return [
        Resource(uri="weather://current", name="current-weather", description="Current weather conditions for any location"),
        Resource(uri="weather://forecast", name="weather-forecast", description="5-day weather forecast data")
    ]

@server.read_resource()
async def handle_read_resource(uri: str) -> str:
    """Read resource content."""
    if uri == "weather://current":
        return await read_current_weather()
    if uri == "weather://forecast":
        return await read_weather_forecast()
    else:
        raise ValueError(f"Unknown resource: {uri}")

@server.list_prompts()
async def handle_list_prompts() -> list[Prompt]:
    """List available prompts."""
    return [
        Prompt(name="weather-summary", description="Generate a natural weather summary"),
        Prompt(name="travel-advice", description="Weather-based travel recommendations")
    ]

@server.get_prompt()
async def handle_get_prompt(name: str, arguments: dict) -> dict:
    """Get prompt details."""
    if name == "weather-summary":
        return await get_weather_summary(arguments)
    if name == "travel-advice":
        return await get_travel_advice(arguments)
    else:
        raise ValueError(f"Unknown prompt: {name}")

async def main():
    """Main function to run the MCP server"""
    async with stdio_server() as (read_stream, write_stream):
        await server.run(read_stream, write_stream, server.create_initialization_options())

if __name__ == "__main__":
    asyncio.run(main())